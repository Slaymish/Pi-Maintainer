Here’s a full‐stack overview of **PiMainteno**, discovered by inspecting every file and module:

1. Project Layout  
   • Root files  
     – `Cargo.toml` / `Cargo.lock`: Rust package metadata & deps (tokio, clap, tracing, anyhow, serde, sled, axum, etc.)  
     – `PiMainteno.toml`: runtime config (LLM, cache path, scheduler cron & projects, systemd units, web host/port)  
     – `README.md`: high-level architecture and design rationale  
     – `upload_service.sh`: build‐and‐deploy helper (cargo build → install binary → copy config → restart systemd service)  
     – `cache/`: on-disk sled database storing prompts, summaries, patches, status flags, commit logs  
     – `codex.md`: the per-project summary file generated by the summarizer  

   • Source tree (`src/`)  
     - main.rs  
     - config.rs  
     - cache.rs  
     - codex_client.rs  
     - summarizer.rs  
     - patcher.rs  
     - scheduler.rs  
     - systemd_monitor.rs  
     - web_server.rs  

2. Entry Point & CLI (src/main.rs)  
   • Parses:  
     – `--config <path>` (default “PiMainteno.toml”)  
     – `--one-shot` (run one scan and exit)  
   • Initializes tracing/logging (tracing + tracing-subscriber)  
   • Loads config via `ConfigLoader::from_path`  
   • Builds shared components:  
     – `DataCache` (sled wrapper)  
     – `CodexClient` (LLM subprocess interface)  
     – `ProjectSummarizer`, `PatchGenerator`, `PatchApplier`  
     – `Scheduler`, `SystemdMonitor`, `WebServer`  
   • If `--one-shot`, runs `scheduler.run_once()` and exits  
   • Otherwise spawns three Tokio tasks:  
     1. Scheduler loop (24-h interval)  
     2. SystemdMonitor listener  
     3. WebServer HTTP UI  
   • Waits for Ctrl+C, then shuts down gracefully  

3. Configuration (src/config.rs & PiMainteno.toml)  
   • Supports TOML or JSON, expands `~`  
   • Sections:  
     – `[llm]`: provider, api_key, model, extra options  
     – `[cache]`: path to sled DB  
     – `[scheduler]`: enabled flag, cron schedule, project paths array  
     – `[systemd_monitor]`: enabled flag, systemd unit names array  
     – `[web]`: host & port  

4. Caching Layer (src/cache.rs)  
   • `DataCache`: thin wrapper over a sled key–value store  
   • Stores state such as last run times, git HEAD hashes, cached LLM outputs, commit logs, error flags  

5. LLM Interface (src/codex_client.rs)  
   • `CodexClient` shells out to the external `codex` CLI  
   • Methods:  
     1. `summarize_project(path) -> String`  
     2. `generate_patch(path) -> unified-diff`  
     3. `generate_commit_message(path, diff) -> String`  
   • Strips ANSI/control sequences, unwraps JSON-L or fenced Markdown  

6. Summaries (src/summarizer.rs)  
   • `ProjectSummarizer`  
   • Computes cache key = git `HEAD` hash  
   • If project unchanged, skips LLM call  
   • Otherwise writes a fresh `codex.md` in the project root and updates cache  

7. Patching (src/patcher.rs)  
   • `PatchGenerator`: calls LLM for a diff, caches under `scheduler.patch.<project>`  
   • `PatchApplier`: applies unified diff via `git apply --whitespace=fix`  
   • Generates commit messages via LLM when applying patches  

8. Scheduler (src/scheduler.rs)  
   • `Scheduler::run_once()` does for each project:  
     1. Summarize (ProjectSummarizer)  
     2. Generate patch (PatchGenerator)  
     3. If non-empty patch:  
        – Apply (PatchApplier)  
        – `git add` & commit with LLM-generated message  
        – `git push` to remote  
        – Log last 50 commit messages under `scheduler.commit_log.<project>`  
        – Restart systemd unit named `<dirname>.service`  
   • Records start/end times and statuses in cache  

9. Systemd Monitor (src/systemd_monitor.rs)  
   • `SystemdMonitor::listen()` stubbed: updates `systemd.last_checked` periodically  
   • Intended to detect unit failures and enqueue fixes, but actual D-Bus/journal polling is unimplemented  

10. Web Dashboard (src/web_server.rs)  
   • Built on Axum + Tower  
   • Serves:  
     – GET `/` → HTML dashboard (shows statuses, summaries, patches, commit history)  
     – GET `/api/status` → JSON of scheduler & systemd statuses  
     – GET `/api/projects` → JSON list of configured projects  
     – GET `/api/projects/:id/summary` → JSON with a single project’s summary  
   • Dashboard “Run Now” button posts to `/api/run`, but no POST handler is wired up yet  

11. Deployment Helper (upload_service.sh)  
   • `cargo build --release` → install binary to `/usr/local/bin/pi-mainteno`  
   • Copies `PiMainteno.toml` to `/etc/pi-mainteno/`  
   • Restarts (`Pi-Maintainer.service`) and shows its status  

12. Observability & Logs  
   • Uses `tracing` for structured logs, configurable via `RUST_LOG`/env filter  
   • All actions, errors, and LLM calls are logged and can be surfaced in the dashboard  

13. Known Gaps & TODOs  
   • Systemd failure detection is a placeholder, needs real D-Bus/journal integration  
   • Web UI manual run (`POST /api/run`) isn’t registered  
   • Could add direct LLM integration (no external `codex` CLI)  
   • Might improve patch review workflow (e.g. “dry-run” mode, staged PRs)  

In essence, **PiMainteno** ties together a clap-driven CLI, a sled-backed cache, an external codex-based LLM interface, Git-centric patch application, a daily scheduler plus systemd listener, and an Axum web dashboard to fully automate (and optionally audit) code maintenance tasks.